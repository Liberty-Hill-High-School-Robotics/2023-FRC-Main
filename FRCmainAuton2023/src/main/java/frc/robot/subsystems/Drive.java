// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import frc.robot.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import java.math.*;

import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import com.revrobotics.SparkMaxRelativeEncoder.Type;

import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import com.ctre.phoenix.sensors.Pigeon2;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.revrobotics.*;
import frc.robot.subsystems.*;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */

public class Drive extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private CANSparkMax cANSparkMAXRF;
    private CANSparkMax cANSparkMAXLF;
    private DifferentialDrive driveMain;
    private CANSparkMax cANSparkMAXRB;
    private CANSparkMax cANSparkMAXLB;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private RelativeEncoder encoderLB;
    private RelativeEncoder encoderRB;
    private RelativeEncoder encoderLF;
    private RelativeEncoder encoderRF;

    private double oldAxisY = 0;
    private double finalAxisY;
    private double tempAxisY;
    private Pigeon2 pigeon2;

    /**
    *
    */
    public Drive() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        cANSparkMAXRF = new CANSparkMax(3, MotorType.kBrushless);

        cANSparkMAXLF = new CANSparkMax(2, MotorType.kBrushless);

        driveMain = new DifferentialDrive(cANSparkMAXLF, cANSparkMAXRF);
        addChild("DriveMain", driveMain);
        driveMain.setSafetyEnabled(true);
        driveMain.setExpiration(0.1);
        driveMain.setMaxOutput(1.0);

        cANSparkMAXRB = new CANSparkMax(4, MotorType.kBrushless);

        cANSparkMAXLB = new CANSparkMax(1, MotorType.kBrushless);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        pigeon2 = new Pigeon2(19);
        // sets the two follow motors to follow the lead motors
        cANSparkMAXRB.follow(cANSparkMAXRF);
        cANSparkMAXLB.follow(cANSparkMAXLF);

        cANSparkMAXRF.setInverted(false);
        cANSparkMAXRB.setInverted(false);
        cANSparkMAXLF.setInverted(true);
        cANSparkMAXLB.setInverted(true);

        encoderLB = cANSparkMAXLB.getEncoder(Type.kHallSensor, 42);
        encoderRB = cANSparkMAXRB.getEncoder(Type.kHallSensor, 42);
        encoderLF = cANSparkMAXLF.getEncoder(Type.kHallSensor, 42);
        encoderRF = cANSparkMAXRF.getEncoder(Type.kHallSensor, 42);

        

    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run

        // smartdashboard

        // temps
        SmartDashboard.putNumber("LeftBackTemp", cANSparkMAXLB.getMotorTemperature());
        SmartDashboard.putNumber("RightBackTemp", cANSparkMAXRB.getMotorTemperature());
        SmartDashboard.putNumber("LeftFrontTemp", cANSparkMAXLF.getMotorTemperature());
        SmartDashboard.putNumber("RightFrontTemp", cANSparkMAXRF.getMotorTemperature());

        SmartDashboard.putNumber("LBMotorVoltage", cANSparkMAXLB.getBusVoltage());
        SmartDashboard.putNumber("LFMotorVoltage", cANSparkMAXLF.getBusVoltage());
        SmartDashboard.putNumber("RBMotorVoltage", cANSparkMAXRB.getBusVoltage());
        SmartDashboard.putNumber("RFMotorVoltage", cANSparkMAXRF.getBusVoltage());

        // encoder CPR

        encoderLB.setVelocityConversionFactor(1);
        encoderLF.setVelocityConversionFactor(1);
        encoderRB.setVelocityConversionFactor(1);
        encoderRF.setVelocityConversionFactor(1);

        SmartDashboard.putNumber("LeftBackPosition", encoderLB.getPosition());
        SmartDashboard.putNumber("RightBackPosition", encoderRB.getPosition());
        SmartDashboard.putNumber("LeftFrontPosition", encoderLF.getPosition());
        SmartDashboard.putNumber("RightFrontPosition", encoderRF.getPosition());

        SmartDashboard.putNumber("LBVelocity", encoderLB.getVelocity());
        SmartDashboard.putNumber("RBVelocity", encoderRB.getVelocity());
        SmartDashboard.putNumber("LFVelocity", encoderLF.getVelocity());
        SmartDashboard.putNumber("RFVelocity", encoderRF.getVelocity());

        // Pigeon2

        SmartDashboard.putNumber("Yaw", pigeon2.getYaw());
        SmartDashboard.putNumber("Pitch", pigeon2.getPitch());
        SmartDashboard.putNumber("Roll", pigeon2.getRoll());

        // need yaw pitch and roll, to feed into the accelerometer
        // SmartDashboard.putNumber("acceleration",
        // pigeon2.getBiasedAccelerometer(null));

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void driveStop() {
        cANSparkMAXRF.stopMotor();
        cANSparkMAXLF.stopMotor();
    }


    public void maxSpeed() {
        driveArcade(1, 0);
   
    }

    // lefty = power rightx = rotation
    public void driveArcade(double power, double rotation) {
        /* 
        double max = .9;
        double rampUp = .001; // error allowed
        double rampD = .001; // ramp down
        double jsAxisY = rightX; // pull num from joystick
        double sub = jsAxisY - oldAxisY;

        if (Math.abs(sub) > rampUp && sub > 0) {
            // test to see if it is going forward
            tempAxisY = oldAxisY + rampUp;
        } else if (Math.abs(sub) > rampD && sub < 0) { // test to see if it is going backwards
            tempAxisY = oldAxisY - rampD;
        } else {
            tempAxisY = jsAxisY;
        }
        // test to see if value exceds max allowed

        if (tempAxisY < max * -1) {
            tempAxisY = max * -1;
        } else if (tempAxisY > max) {
            tempAxisY = max;
        }
        finalAxisY = tempAxisY;
        oldAxisY = finalAxisY;
        */
        finalAxisY = power;
        driveMain.arcadeDrive(finalAxisY, rotation);
    }
}
