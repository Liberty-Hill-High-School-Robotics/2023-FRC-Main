// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import com.ctre.phoenix.sensors.Pigeon2;
import com.revrobotics.AbsoluteEncoder;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import com.revrobotics.RelativeEncoder;
import com.revrobotics.SparkMaxRelativeEncoder.Type;

import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

/**
 *
 */

public class Drive extends SubsystemBase {

    private CANSparkMax rightLeader;
    private CANSparkMax leftLeader;
    private DifferentialDrive driveMain;
    private CANSparkMax rightFollow;
    private CANSparkMax leftFollow;

    private RelativeEncoder encoderLeftFollow;
    private RelativeEncoder encoderRightFollow;
    private RelativeEncoder encoderLeftLeader;
    private RelativeEncoder encoderRightLeader;

    private double oldAxisY = 0;
    private double finalAxisY;
    private double tempAxisY;
    private Pigeon2 pigeon2;

    /**
    *
    */
    public Drive() {

        rightLeader = new CANSparkMax(3, MotorType.kBrushless);
        rightLeader.restoreFactoryDefaults();
        rightLeader.setInverted(false);

        leftLeader = new CANSparkMax(2, MotorType.kBrushless);
        leftLeader.restoreFactoryDefaults();
        leftLeader.setInverted(true);

        driveMain = new DifferentialDrive(leftLeader, rightLeader);
        addChild("DriveMain", driveMain);
        driveMain.setSafetyEnabled(true);
        driveMain.setExpiration(0.1);
        driveMain.setMaxOutput(1.0);

        rightFollow = new CANSparkMax(4, MotorType.kBrushless);
        rightFollow.restoreFactoryDefaults();
        // rightFollow.setInverted(false);
        rightFollow.follow(rightLeader, false);

        leftFollow = new CANSparkMax(1, MotorType.kBrushless);
        leftFollow.restoreFactoryDefaults();
        leftFollow.follow(leftLeader, false); // Same direction as leader

        pigeon2 = new Pigeon2(19);
        // sets the two follow motors to follow the lead motors

        encoderLeftFollow = leftFollow.getEncoder(Type.kHallSensor, 42);
        encoderLeftFollow.setVelocityConversionFactor(1);

        encoderRightFollow = rightFollow.getEncoder(Type.kHallSensor, 42);
        encoderRightFollow.setVelocityConversionFactor(1);

        encoderLeftLeader = leftLeader.getEncoder(Type.kHallSensor, 42);
        encoderLeftLeader.setVelocityConversionFactor(1);

        encoderRightLeader = rightLeader.getEncoder(Type.kHallSensor, 42);
        encoderRightLeader.setVelocityConversionFactor(1);

    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run

        // smartdashboard

        // temps
        SmartDashboard.putNumber("LeftBackTemp", leftFollow.getMotorTemperature());
        SmartDashboard.putNumber("RightBackTemp", rightFollow.getMotorTemperature());
        SmartDashboard.putNumber("LeftFrontTemp", leftLeader.getMotorTemperature());
        SmartDashboard.putNumber("RightFrontTemp", rightLeader.getMotorTemperature());

        SmartDashboard.putNumber("LBMotorVoltage", leftFollow.getBusVoltage());
        SmartDashboard.putNumber("LFMotorVoltage", leftLeader.getBusVoltage());
        SmartDashboard.putNumber("RBMotorVoltage", rightFollow.getBusVoltage());
        SmartDashboard.putNumber("RFMotorVoltage", rightLeader.getBusVoltage());

        // encoder CPR

        SmartDashboard.putNumber("LeftBackPosition", encoderLeftFollow.getPosition());
        SmartDashboard.putNumber("RightBackPosition", encoderRightFollow.getPosition());
        SmartDashboard.putNumber("LeftFrontPosition", encoderLeftLeader.getPosition());
        SmartDashboard.putNumber("RightFrontPosition", encoderRightLeader.getPosition());

        SmartDashboard.putNumber("LBVelocity", encoderLeftFollow.getVelocity());
        SmartDashboard.putNumber("RBVelocity", encoderRightFollow.getVelocity());
        SmartDashboard.putNumber("LFVelocity", encoderLeftLeader.getVelocity());
        SmartDashboard.putNumber("RFVelocity", encoderRightLeader.getVelocity());

        // Pigeon2

        SmartDashboard.putNumber("Yaw", pigeon2.getYaw());
        SmartDashboard.putNumber("Pitch", pigeon2.getPitch());
        SmartDashboard.putNumber("Roll", pigeon2.getRoll());

        // need yaw pitch and roll, to feed into the accelerometer
        // SmartDashboard.putNumber("acceleration",
        // pigeon2.getBiasedAccelerometer(null));

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void driveStop() {
        rightLeader.stopMotor();
        leftLeader.stopMotor();
    }

    public void maxSpeed() {
        driveArcade(1, 0);

    }

    // lefty = power rightx = rotation
    public void driveArcade(double power, double rotation) {
        /*
         * double max = .9;
         * double rampUp = .001; // error allowed
         * double rampD = .001; // ramp down
         * double jsAxisY = rightX; // pull num from joystick
         * double sub = jsAxisY - oldAxisY;
         * 
         * if (Math.abs(sub) > rampUp && sub > 0) {
         * // test to see if it is going forward
         * tempAxisY = oldAxisY + rampUp;
         * } else if (Math.abs(sub) > rampD && sub < 0) { // test to see if it is going
         * backwards
         * tempAxisY = oldAxisY - rampD;
         * } else {
         * tempAxisY = jsAxisY;
         * }
         * // test to see if value exceds max allowed
         * 
         * if (tempAxisY < max * -1) {
         * tempAxisY = max * -1;
         * } else if (tempAxisY > max) {
         * tempAxisY = max;
         * }
         * finalAxisY = tempAxisY;
         * oldAxisY = finalAxisY;
         */
        finalAxisY = power;
        driveMain.arcadeDrive(finalAxisY, rotation);
    }
}
